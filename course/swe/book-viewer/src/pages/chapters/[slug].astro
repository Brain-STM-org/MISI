---
/**
 * Dynamic chapter page using Astro Content Collections
 *
 * Renders MDX content with pedagogical components
 */
import { getCollection, type CollectionEntry } from 'astro:content';
import BookLayout from '../../layouts/BookLayout.astro';
import { getChapter, getNextChapter, getPrevChapter } from '../../lib/chapters';
import TableOfContents from '../../components/TableOfContents.astro';
import type { TocEntry } from '../../lib/rehype-toc';

// MDX Components
import ConceptCard from '../../components/ConceptCard';
import QuestionBlock from '../../components/QuestionBlock';
import Checkpoint from '../../components/Checkpoint';
import TryBlock from '../../components/TryBlock';
import Callout from '../../components/Callout';
import ConceptReviewSidebar from '../../components/ConceptReviewSidebar';

// Generate static paths from content collection
export async function getStaticPaths() {
  const chapters = await getCollection('chapters');
  return chapters.map((chapter) => ({
    params: { slug: chapter.slug },
    props: { chapter },
  }));
}

interface Props {
  chapter: CollectionEntry<'chapters'>;
}

const { chapter } = Astro.props;
const { slug } = Astro.params;

// Get chapter metadata
const chapterMeta = getChapter(slug);
const nextChapter = getNextChapter(slug);
const prevChapter = getPrevChapter(slug);

// Render the MDX content
const { Content, remarkPluginFrontmatter } = await chapter.render();

// Get TOC from the rendered file (if available)
const toc: TocEntry[] = (Astro.props.chapter as any).data?.toc || [];

// Use frontmatter title or fallback to metadata
const title = chapter.data.title || chapterMeta?.title || 'Chapter';
const tier = chapter.data.tier || chapterMeta?.tier || 1;
const estimatedMinutes = chapter.data.estimatedMinutes || chapterMeta?.estimatedMinutes || 20;
---

<BookLayout title={title} chapterSlug={slug}>
  <div class="flex gap-8">
    <!-- Main content -->
    <article class="flex-1 min-w-0">
      <!-- Chapter header -->
      <header class="mb-8 pb-6 border-b border-gray-200 dark:border-gray-700">
        <div class="flex items-center gap-2 text-sm text-gray-500 dark:text-gray-400 mb-2">
          <span class="px-2 py-1 bg-gray-100 dark:bg-gray-800 rounded text-xs font-medium">
            Tier {tier}
          </span>
          <span>•</span>
          <span>Chapter {chapterMeta?.number || '??'}</span>
          <span>•</span>
          <span>{estimatedMinutes} min read</span>
        </div>
        <h1 class="text-3xl font-bold text-gray-900 dark:text-white">
          {title}
        </h1>
      </header>

      <!-- MDX Content with components -->
      <div class="prose prose-lg dark:prose-invert max-w-none
        prose-headings:scroll-mt-20
        prose-a:text-blue-600 dark:prose-a:text-blue-400
        prose-code:text-gray-800 dark:prose-code:text-gray-200
        prose-pre:bg-gray-900 dark:prose-pre:bg-gray-950">
        <Content
          components={{
            ConceptCard,
            QuestionBlock,
            Checkpoint,
            TryBlock,
            Callout,
          }}
        />
      </div>

      <!-- Chapter navigation -->
      <nav class="mt-12 pt-8 border-t border-gray-200 dark:border-gray-700 flex justify-between items-center">
        {prevChapter ? (
          <a
            href={`/chapters/${prevChapter.slug}`}
            class="group flex items-center gap-2 text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400"
          >
            <svg class="w-5 h-5 transition-transform group-hover:-translate-x-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
            </svg>
            <span class="text-sm">
              <span class="block text-xs text-gray-400">Previous</span>
              {prevChapter.title}
            </span>
          </a>
        ) : <div />}

        {nextChapter ? (
          <a
            href={`/chapters/${nextChapter.slug}`}
            class="group flex items-center gap-2 text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 text-right"
          >
            <span class="text-sm">
              <span class="block text-xs text-gray-400">Next</span>
              {nextChapter.title}
            </span>
            <svg class="w-5 h-5 transition-transform group-hover:translate-x-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
            </svg>
          </a>
        ) : <div />}
      </nav>
    </article>

    <!-- Table of Contents sidebar (desktop only) -->
    <aside class="hidden xl:block w-64 flex-shrink-0">
      <div class="sticky top-24">
        <TableOfContents entries={toc} />
      </div>
    </aside>
  </div>

  <!-- Floating concept review button -->
  <ConceptReviewSidebar client:only="react" chapterSlug={slug} />

  <!-- Hidden element to pass chapter slug to client script -->
  <div id="chapter-data" data-chapter-slug={slug} class="hidden"></div>
</BookLayout>

<script>
  import { startChapter, reviewConcept, revealQuestion, updateCheckpoint, addBookmark, removeBookmark, progressStore } from '../../lib/progress';

  // Get chapter slug from data attribute
  const chapterData = document.getElementById('chapter-data');
  const chapterSlug = chapterData?.dataset.chapterSlug;

  if (chapterSlug) {
    // Initialize chapter tracking
    startChapter(chapterSlug);

    // Initialize concept review buttons
    const conceptCards = document.querySelectorAll('.concept-card');
    conceptCards.forEach((card) => {
      const conceptId = card.getAttribute('data-concept-id');
      const btn = card.querySelector('.concept-review-btn');
      if (!btn || !conceptId) return;

      function updateReviewButton() {
        const progress = progressStore.get();
        const reviews = progress.chapters[chapterSlug]?.conceptsReviewed?.[conceptId];
        const isReviewed = reviews && reviews.length > 0;

        if (isReviewed) {
          btn.textContent = '✓ Reviewed';
          btn.classList.remove('bg-gray-100', 'dark:bg-gray-700', 'text-gray-600', 'dark:text-gray-400');
          btn.classList.add('bg-green-100', 'dark:bg-green-900', 'text-green-700', 'dark:text-green-300');
          btn.title = 'Reviewed';
        } else {
          btn.textContent = 'Mark reviewed';
          btn.classList.add('bg-gray-100', 'dark:bg-gray-700', 'text-gray-600', 'dark:text-gray-400');
          btn.classList.remove('bg-green-100', 'dark:bg-green-900', 'text-green-700', 'dark:text-green-300');
          btn.title = 'Mark as reviewed for spaced repetition';
        }
      }

      btn.addEventListener('click', () => {
        reviewConcept(chapterSlug, conceptId);
      });

      progressStore.subscribe(updateReviewButton);
      updateReviewButton();
    });

    // Add bookmark buttons to headings
    const headings = document.querySelectorAll('article h2[id], article h3[id]');

    headings.forEach((heading) => {
      const headingSlug = heading.id;
      const headingText = heading.textContent?.trim() || '';

      // Create bookmark button
      const btn = document.createElement('button');
      btn.className = 'bookmark-btn ml-2 p-1 rounded transition-colors text-gray-300 hover:text-gray-400 dark:text-gray-600 dark:hover:text-gray-500';
      btn.title = 'Bookmark this section';
      btn.innerHTML = `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z" /></svg>`;

      // Check if already bookmarked
      function updateButton() {
        const progress = progressStore.get();
        const bookmarks = progress.bookmarks || [];
        const isBookmarked = bookmarks.some(
          b => b.chapterSlug === chapterSlug && b.headingSlug === headingSlug
        );
        if (isBookmarked) {
          btn.classList.add('text-yellow-500', 'hover:text-yellow-600');
          btn.classList.remove('text-gray-300', 'hover:text-gray-400', 'dark:text-gray-600', 'dark:hover:text-gray-500');
          btn.querySelector('svg').setAttribute('fill', 'currentColor');
          btn.title = 'Remove bookmark';
        } else {
          btn.classList.remove('text-yellow-500', 'hover:text-yellow-600');
          btn.classList.add('text-gray-300', 'hover:text-gray-400', 'dark:text-gray-600', 'dark:hover:text-gray-500');
          btn.querySelector('svg').setAttribute('fill', 'none');
          btn.title = 'Bookmark this section';
        }
      }

      btn.addEventListener('click', (e) => {
        e.preventDefault();
        const progress = progressStore.get();
        const bookmarks = progress.bookmarks || [];
        const isBookmarked = bookmarks.some(
          b => b.chapterSlug === chapterSlug && b.headingSlug === headingSlug
        );
        if (isBookmarked) {
          removeBookmark(chapterSlug, headingSlug);
        } else {
          addBookmark(chapterSlug, headingSlug, headingText);
        }
      });

      progressStore.subscribe(updateButton);
      updateButton();

      // Make heading a flex container
      heading.style.display = 'flex';
      heading.style.alignItems = 'center';
      heading.appendChild(btn);
    });

    // Initialize QuestionBlock reveal buttons
    document.querySelectorAll('.question-block').forEach((block) => {
      const questionId = block.getAttribute('data-question-id');
      const revealBtn = block.querySelector('.question-reveal-btn');
      const prompt = block.querySelector('.question-prompt');
      const answer = block.querySelector('.question-answer');

      if (!revealBtn || !prompt || !answer) return;

      function checkRevealed() {
        const progress = progressStore.get();
        const revealed = progress.chapters[chapterSlug]?.questionsRevealed || [];
        if (revealed.includes(questionId)) {
          prompt.classList.add('hidden');
          answer.classList.remove('hidden');
        }
      }

      revealBtn.addEventListener('click', () => {
        prompt.classList.add('hidden');
        answer.classList.remove('hidden');
        revealQuestion(chapterSlug, questionId);
      });

      progressStore.subscribe(checkRevealed);
      checkRevealed();
    });

    // Initialize TryBlock hint buttons
    document.querySelectorAll('.try-block').forEach((block) => {
      const hintBtn = block.querySelector('.try-hint-btn');
      const hint = block.querySelector('.try-hint');

      if (!hintBtn || !hint) return;

      hintBtn.addEventListener('click', () => {
        hintBtn.classList.add('hidden');
        hint.classList.remove('hidden');
      });
    });

    // Initialize Checkpoint components
    document.querySelectorAll('.checkpoint').forEach((block) => {
      const checkpointId = block.getAttribute('data-checkpoint-id');
      const itemsJson = block.getAttribute('data-items');
      const items = JSON.parse(itemsJson || '[]');
      const checkboxes = block.querySelectorAll('.checkpoint-item');
      const countEl = block.querySelector('.checkpoint-count');
      const completeMsg = block.querySelector('.checkpoint-complete-msg');
      const progressBar = block.querySelector('.checkpoint-progress') as HTMLElement | null;
      const confidenceBtns = block.querySelectorAll('.confidence-btn');
      const confidenceLabel = block.querySelector('.checkpoint-confidence-label');
      const submitBtn = block.querySelector('.checkpoint-submit') as HTMLButtonElement | null;
      const savedMsg = block.querySelector('.checkpoint-saved');

      let checkedItems = items.map(() => false);
      let confidence = 0;
      const confidenceColors = ['bg-red-500', 'bg-orange-500', 'bg-yellow-500', 'bg-lime-500', 'bg-green-500'];
      const confidenceLabels = ['Not confident', 'Slightly confident', 'Somewhat confident', 'Confident', 'Very confident'];

      function updateUI() {
        const checkedCount = checkedItems.filter(Boolean).length;
        if (countEl) countEl.textContent = `${checkedCount} of ${items.length} checked`;
        if (progressBar) progressBar.style.width = `${(checkedCount / items.length) * 100}%`;
        if (completeMsg) {
          if (checkedCount === items.length) {
            completeMsg.classList.remove('hidden');
          } else {
            completeMsg.classList.add('hidden');
          }
        }

        // Update confidence buttons
        confidenceBtns.forEach((btn, i) => {
          const level = i + 1;
          btn.classList.remove(...confidenceColors);
          if (confidence >= level) {
            btn.classList.add(confidenceColors[i]);
            btn.classList.remove('opacity-50');
            btn.classList.add('opacity-100');
          } else {
            btn.classList.add('bg-gray-200', 'dark:bg-gray-700', 'opacity-50');
          }
        });

        if (confidence > 0 && confidenceLabel) {
          confidenceLabel.textContent = confidenceLabels[confidence - 1];
          confidenceLabel.classList.remove('hidden');
        }

        // Update submit button
        if (submitBtn) {
          if (confidence > 0) {
            submitBtn.disabled = false;
            submitBtn.classList.remove('bg-gray-300', 'text-gray-500', 'dark:bg-gray-700', 'dark:text-gray-500', 'cursor-not-allowed');
            submitBtn.classList.add('bg-emerald-600', 'text-white', 'hover:bg-emerald-700', 'cursor-pointer');
          }
        }
      }

      checkboxes.forEach((checkbox, index) => {
        checkbox.addEventListener('change', () => {
          checkedItems[index] = (checkbox as HTMLInputElement).checked;
          updateUI();
        });
      });

      confidenceBtns.forEach((btn) => {
        btn.addEventListener('click', () => {
          confidence = parseInt(btn.getAttribute('data-confidence') || '0');
          updateUI();
        });
      });

      // Load saved state
      function loadState() {
        const progress = progressStore.get();
        const checkpoint = progress.chapters[chapterSlug]?.checkpoints?.[checkpointId];
        if (checkpoint) {
          checkedItems = checkpoint.items.length === items.length ? checkpoint.items : items.map(() => false);
          confidence = checkpoint.confidence;
          checkboxes.forEach((cb, i) => { (cb as HTMLInputElement).checked = checkedItems[i]; });
          updateUI();
          if (checkpoint.confidence > 0) {
            submitBtn?.classList.add('hidden');
            savedMsg?.classList.remove('hidden');
            checkboxes.forEach(cb => (cb as HTMLInputElement).disabled = true);
            confidenceBtns.forEach(btn => (btn as HTMLButtonElement).disabled = true);
          }
        }
      }

      submitBtn?.addEventListener('click', () => {
        updateCheckpoint(chapterSlug, checkpointId, { items: checkedItems, confidence });
        submitBtn.classList.add('hidden');
        savedMsg?.classList.remove('hidden');
        checkboxes.forEach(cb => (cb as HTMLInputElement).disabled = true);
        confidenceBtns.forEach(btn => (btn as HTMLButtonElement).disabled = true);
      });

      progressStore.subscribe(loadState);
      loadState();
    });
  }
</script>
